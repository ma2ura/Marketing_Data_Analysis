{
  "hash": "b4516f2dc8681401a2738e9e8c9fcfaf",
  "result": {
    "engine": "knitr",
    "markdown": "## 第5章 基礎統計学復習\n\n経営学部の1回生がおおよそ学んでいるであろう統計学の内容を、Rコードとともに復習します。\nテキストの内容に加えて、コードの効率化や関数化についても解説します。\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-1\npacman::p_load(tidyverse, readxl, pwr, knitr)\n```\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-2\nset.seed(442)\n# サイコロ\ndie <- 1:6\n# サイコロを1回振る\nd <- sample(die, size = 1, replace = TRUE)\n# 結果の表示\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n:::\n\n\n同じコードを3回以上書いているなと思ったら、ループ処理や関数化を検討しましょう。\n`for()`関数を使ったり、サイコロを投げる回数を引数にした関数を作成したりする方法があります。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nd1 <- sample(die, size = 10, replace = TRUE)\nd2 <- sample(die, size = 10, replace = TRUE)\nd3 <- sample(die, size = 10, replace = TRUE)\n```\n:::\n\n\nをまとめて書くと、次のようになります。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nd <- list() # 空のリストを作成\nfor (i in 1:3) { # ループ処理\n  d[[i]] <- sample(die, size = 10, replace = TRUE)\n}\nd # 結果の表示\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n [1] 4 4 3 2 6 3 5 2 6 5\n\n[[2]]\n [1] 3 2 6 6 5 4 6 4 3 1\n\n[[3]]\n [1] 6 1 1 5 2 1 4 5 2 2\n```\n\n\n:::\n:::\n\n\nこれをさらに発展させて、後で変更する可能性のある変数である試行回数やサイコロを振る回数を別に設定しておいて、コードを読みやすく、また変更しやすくします。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-line-numbers=\"1:2\"}\ntrials <- 3 # 試行回数\nsize <- 10 # サイコロを振る回数\nd_mean <- numeric(trials) # 空のリストを作成\nfor (i in 1:trials) {\n  d_mean[i] <- mean(sample(die, size = size, replace = TRUE))\n}\nd_mean\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.2 3.3 4.0\n```\n\n\n:::\n:::\n\n\n試行回数`trials`とサイコロを振る回数`size`を引数にした関数を作成すると、さらに便利になります。\nここでは、自作関数`dice_mean()`を定義してみましょう。\nデフォルト値として、試行回数を3回、サイコロを振る回数を10回に設定しています。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndice_mean <- function(trials = 3, size = 10) {\n  d_mean <- numeric(trials) # 空のリストを作成\n  for (i in 1:trials) {\n    d_mean[i] <- mean(sample(die, size = size, replace = TRUE))\n  }\n  return(d_mean)\n}\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndice_mean() # デフォルト値で実行\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.4 2.5 4.4\n```\n\n\n:::\n\n```{.r .cell-code}\ndice_mean(trials = 5, size = 20) # 引数を指定して実行\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.15 3.55 3.65 3.50 3.25\n```\n\n\n:::\n\n```{.r .cell-code}\ndice_mean(5, 20) # 省略形でもOK\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.80 4.30 2.75 3.70 3.05\n```\n\n\n:::\n:::\n\n\nこの関数を使って、サイコロを10回、100回、1,000回振ったときの平均をそれぞれ3回ずつ試行してみましょう。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(352)\nsize = c(10, 100, 1000)\nd_mean <- list()\n\nfor (i in seq_along(size)) {\n  d_mean[[i]] <- dice_mean(trials = 3, size = size[i])\n}\n\nd_mean_mat <- do.call(rbind, d_mean)\n\n# 列名を付与\ncolnames(d_mean_mat) <- paste0(\"試行\", 1:ncol(d_mean_mat))\n# 行名を付与\nrownames(d_mean_mat) <- paste0(\"サイコロを\", size, \"回振る\")\n# 表として出力\nknitr::kable(\n  d_mean_mat,\n  caption = \"サイコロの標本平均（各サイズ3回ずつ）\",\n  align = \"ccc\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: サイコロの標本平均（各サイズ3回ずつ）\n\n|                     | 試行1 | 試行2 | 試行3 |\n|:--------------------|:-----:|:-----:|:-----:|\n|サイコロを10回振る   | 3.200 | 3.000 | 2.400 |\n|サイコロを100回振る  | 3.440 | 3.340 | 3.560 |\n|サイコロを1000回振る | 3.433 | 3.446 | 3.554 |\n\n\n:::\n:::\n\n\n`tidyverse`の`purrr`パッケージを使うと、さらに簡潔に書けます。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(352)\ntrials <- 3 # 試行回数\nsizes <- c(10, 100, 1000) # サイコロを振る回数\n# map_dfr()でデータフレームを直接作成\nd_mean_df <- map_dfr(sizes, function(n) {\n  # replicate()で3回繰り返し試行\n  results <- replicate(\n    trials, \n    mean(sample(die, size = n, replace = TRUE))\n    )\n  set_names(results, paste0(\"試行\", 1:3))\n  })\n\nresult <- d_mean_df |> \n  mutate(条件 = paste0(\"サイコロを\", sizes, \"回振る\")) |> \n  relocate(条件) # 「条件」列を一番左へ移動\n\n# 出力\nkable(\n  result,\n  caption = \"サイコロの標本平均（各サイズ3回ずつ）\",\n  align = \"cccc\"\n)\n```\n\n::: {.cell-output-display}\n\n\nTable: サイコロの標本平均（各サイズ3回ずつ）\n\n|         条件         | 試行1 | 試行2 | 試行3 |\n|:--------------------:|:-----:|:-----:|:-----:|\n|  サイコロを10回振る  | 3.200 | 3.000 | 2.400 |\n| サイコロを100回振る  | 3.440 | 3.340 | 3.560 |\n| サイコロを1000回振る | 3.433 | 3.446 | 3.554 |\n\n\n:::\n:::\n\n\n<!--- \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(352)\nd_mean <- numeric(3) # 空のリストを作成\n# 繰り返し処理\nfor (i in 1:3) {\n  d_mean[i] <- mean(sample(die, size = 10, replace = TRUE))\n}\n# 各試行の平均を計算\nd_lln <- matrix(d_mean, nrow = 1)\ncolnames(d_lln) <- c(\"10回試行の平均\", \"100回試行の平均\", \"1,000回試行の平均\")\n# kableで結果の表示\nknitr::kable(\n  d_mean, # 表示するオブジェクト\n  caption = \"サイコロの標本平均比較\",  \n  align = \"ccc\" # 3行を中央揃え\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: サイコロの標本平均比較\n\n|  x  |\n|:---:|\n| 3.2 |\n| 3.0 |\n| 2.4 |\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-3\nset.seed(352)\n\n# サイコロを10回振る\nd1 <- sample(die, size = 10, replace = TRUE)\nd2 <- sample(die, size = 10, replace = TRUE)\nd3 <- sample(die, size = 10, replace = TRUE)\n# 各試行の平均を計算\nd_mean <- matrix(c(mean(d1), mean(d2), mean(d3)), nrow = 1)\n# 列名の設定\ncolnames(d_mean) <- c(\"d1の平均\", \"d2の平均\", \"d3の平均\")\n# kableで結果の表示\nknitr::kable(\n  d_mean, # 表示するオブジェクト\n  caption = \"サイコロの標本平均比較\",  \n  align = \"ccc\" # 3行を中央揃え\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: サイコロの標本平均比較\n\n| d1の平均 | d2の平均 | d3の平均 |\n|:--------:|:--------:|:--------:|\n|   3.2    |    3     |   2.4    |\n\n\n:::\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-4\nset.seed(541)\n# サイコロをそれぞれ10回、100回、1000回振る\nd10 <- sample(die, size = 10, replace = TRUE)\nd100 <- sample(die, size = 100, replace = TRUE)\nd1000 <- sample(die, size = 1000, replace = TRUE)\n\nd_lln <- matrix(c(mean(d10), mean(d100), mean(d1000)), nrow = 1)\n\ncolnames(d_lln) <- c(\"10回試行の平均\", \"100回試行の平均\", \"1,000回試行の平均\")\nknitr::kable(\n  d_lln, \n  caption = \"サイコロの標本平均比較 2\", \n  align = \"ccc\"\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: サイコロの標本平均比較 2\n\n| 10回試行の平均 | 100回試行の平均 | 1,000回試行の平均 |\n|:--------------:|:---------------:|:-----------------:|\n|       3        |      3.36       |       3.516       |\n\n\n:::\n:::\n\n\n--->\n\n## 区間推定\n\nいま、標準正規分布に従う母集団から抽出した無作為標本$Z_1, Z_2, ..., Z_n$を考えます。\n標準正規分布の確率分布関数$\\phi(z)$を用いると、次のように表せます。\n$$\nP \\left( -z_{\\frac{\\alpha}{2}} \\leq \\frac{\\bar{Z} - \\mu}{\\frac{\\sigma}{\\sqrt{n}}} \\leq z_{\\frac{\\alpha}{2}} \\right) = 1 - \\alpha\n$$\n\n\n### 電球の寿命データで区間推定\n\n例として、次のような白熱電球の寿命データが手元にあるものとしましょう。\nここで、以下のことが分かっているものとします。\n\n- 平均寿命が1800時間である。\n- 寿命の標準偏差$\\sigma $は180時間である。\n- 平均寿命は正規分布に従う。\n\n図にすると次のようになります。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\naverate <- 1800\nstandard_dev <- 180\nrnorm(1000, mean = averate, sd = standard_dev) |>\n  as_tibble() |>\n  ggplot(aes(x = value)) +\n  stat_function(\n    fun = dnorm,\n    args = list(mean = averate, sd = standard_dev),\n    color = \"red\",\n    size = 1\n    ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](chapter05_files/figure-html/normal_dist-1.png){fig-align='center' width=3150}\n:::\n:::\n\n\n\nこの分布から抽出したと想定される16個の電球の寿命データが以下の通りです。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-5\nbulb <- c(# 白熱電球の寿命データ\n    1939.6, 1680.3, 1982.1, 2215.6,\n    2092.5, 1928.9, 2003.8, 1955.5,\n    1800.1, 1659.5, 2066.2, 2107.2,\n    2085.5, 1878.6, 2007.6, 1816.1\n  )\nmean(bulb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1951.194\n```\n\n\n:::\n\n```{.r .cell-code}\nsd(bulb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 154.4567\n```\n\n\n:::\n:::\n\n\n先ほどの分布にこのデータのヒストグラムを重ねると、次のようになります。\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# ヒストグラムの作成\nbulb_df <- tibble(lifetime = bulb)\nbulb_df |> \n  ggplot(aes(x = lifetime)) +\n  geom_histogram(\n    aes(y = ..density..),\n    bins = 8,\n    fill = \"lightblue\",\n    color = \"black\",\n    alpha = 0.7\n    ) +\n  stat_function(\n    fun = dnorm,\n    args = list(mean = averate, sd = standard_dev),\n    color = \"red\",\n    size = 1\n    ) +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](chapter05_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=3150}\n:::\n:::\n\n\nそのとき、この手元にある16個の電球の寿命データの平均値が、母平均1800の周りでどの範囲に入るかを95％の信頼水準で推定してみましょう。\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# t検定の実施\nbulb_ci <- t.test(bulb)\nbulb_ci$conf.int \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1868.890 2033.498\nattr(,\"conf.level\")\n[1] 0.95\n```\n\n\n:::\n\n```{.r .cell-code}\n# 信頼区間の出力（デフォルトで 95％信頼水準）\n```\n:::\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-6\nqnorm(0.025, lower.tail = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.959964\n```\n\n\n:::\n\n```{.r .cell-code}\n# 標準正規分布における上側 2.5％点の分位点を求める。\n```\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-7\nn <- length(bulb) # 標本サイズの計算\nz <- qnorm(0.025, lower.tail = FALSE) # 上側2.5％点の分位点\nxbar <- mean(bulb) # 標本平均の計算\nsigma <- 180 # 母標準偏差の設定\n\n# 信頼区間の計算\nupper <- xbar + z * (sigma / sqrt(n))\nlower <- xbar - z * (sigma / sqrt(n))\n\n# 結果のまとめと出力\nci.bulb <- matrix(c(lower, upper), nrow = 1)\ncolnames(ci.bulb) <- c(\"ci.lower\", \"ci.upper\")\nknitr::kable(\n  ci.bulb, \n  caption = \"Bulb data CI (95％)\", \n  align = \"cc\"\n  )\n```\n\n::: {.cell-output-display}\n\n\nTable: Bulb data CI (95％)\n\n| ci.lower | ci.upper |\n|:--------:|:--------:|\n| 1862.995 | 2039.392 |\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-8\nmean(bulb)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1951.194\n```\n\n\n:::\n\n```{.r .cell-code}\n# コード5-9\nt.test(bulb, alternative = \"two.sided\", mu = 1800)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tOne Sample t-test\n\ndata:  bulb\nt = 3.9155, df = 15, p-value = 0.001377\nalternative hypothesis: true mean is not equal to 1800\n95 percent confidence interval:\n 1868.890 2033.498\nsample estimates:\nmean of x \n 1951.194 \n```\n\n\n:::\n\n```{.r .cell-code}\n# コード5-10\nn <- length(bulb) # 標本サイズの計算\nz <- qnorm(0.025, lower.tail = FALSE) # 上側2.5％点の分位点\nxbar <- mean(bulb) # 標本平均の計算\nsigma <- 180 # 母標準偏差の設定\nmu <- 1800 # 帰無仮説の平均値 \n# Z値の計算\nZ <- (xbar - mu) / (sigma / sqrt(n))\nZ\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.359861\n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-11\n# データの読み込みと前処理\nfirmdata <- readxl::read_xlsx(\"data/MktRes_firmdata.xlsx\")\nfirm2018 <- firmdata |>\n  filter(fyear == 2018) |>\n  mutate(\n    ad_dummy = ifelse(adint > median(adint), 1, 0)\n    )\n# t検定の実施\nt.test(sales ~ ad_dummy, data = firm2018)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tWelch Two Sample t-test\n\ndata:  sales by ad_dummy\nt = -3.3989, df = 85.686, p-value = 0.001029\nalternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0\n95 percent confidence interval:\n -1674283.1  -438496.1\nsample estimates:\nmean in group 0 mean in group 1 \n       725009.7       1781399.3 \n```\n\n\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-12\nvar.test(sales ~ ad_dummy, data = firm2018, ratio = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\tF test to compare two variances\n\ndata:  sales by ad_dummy\nF = 0.10863, num df = 74, denom df = 71, p-value < 2.2e-16\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.06821636 0.17258882\nsample estimates:\nratio of variances \n         0.1086276 \n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# 効果量d=0.8、検出力0.8、有意水準0.05の場合の\n# 必要標本サイズの推定\nest_n <- pwr.t.test(d = 0.8, power = 0.8, sig.level = 0.05)\nest_n\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Two-sample t test power calculation \n\n              n = 25.52458\n              d = 0.8\n      sig.level = 0.05\n          power = 0.8\n    alternative = two.sided\n\nNOTE: n is number in *each* group\n```\n\n\n:::\n:::\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-15\nplot(est_n)\n```\n\n::: {.cell-output-display}\n![](chapter05_files/figure-html/code5-15-1.png){fig-align='center' width=3150}\n:::\n:::\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# コード5-16\npwr.t.test(d = 0.8, n = 26, sig.level = 0.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n     Two-sample t test power calculation \n\n              n = 26\n              d = 0.8\n      sig.level = 0.05\n          power = 0.8074866\n    alternative = two.sided\n\nNOTE: n is number in *each* group\n```\n\n\n:::\n:::\n\n",
    "supporting": [
      "chapter05_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}